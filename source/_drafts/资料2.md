---
title: 资料2
tags:
category: 草稿箱
---

## 用过哪些多线程的方法

wait
notify
sleep
yield
join
currentThread
isAlive
getId
interrupt
interrupted()：判断当前线程是否处于中断状态; 并清除线程的中断状态（即被重置为fals状态,未中断）。（— —static方法）
isInterrupted()：判断线程Thread对象是否已经处于中断状态。但不清除状态标志

## 线程同步有几种方法

关键字 synchronized,用对象的内置锁

用reentrantlock提供的锁

使用volatile关键字访问内存里面的值

使用threadlocal类给每个线程创建本地副本

[使用并发包例如阻塞队列 LinkedBlockedQueue 或者ArrayBlockedQueue](https://blog.csdn.net/lfj19941225/article/details/88549965 "使用阻塞队列例如 LinkedBlockedQueue 或者ArrayBlockedQueue")


## JVM模型

[![Java8内存模型](https://img2018.cnblogs.com/blog/1743446/201907/1743446-20190731144659459-260296720.png "Java8内存模型")](https://img2018.cnblogs.com/blog/1743446/201907/1743446-20190731144659459-260296720.png "Java8内存模型")

https://www.nowcoder.com/discuss/151138?type=1
![内存模型](https://img2018.cnblogs.com/blog/1743446/201907/1743446-20190731144659459-260296720.png "内存模型")

![](https://uploadfiles.nowcoder.com/files/20190110/7380095_1547132982664_4685968-2502bef3bd1d1692.png)

![文件进入堆的过程](https://uploadfiles.nowcoder.com/files/20190110/7380095_1547132982545_4685968-57ed647f10498521.png "文件进入堆的过程")


## JVM参数
- MaxHeapFreeRatio: GC后如果发现空闲堆内存占到整个预估堆内存的N%(百分比)，则收缩堆内存的预估最大值, 预估堆内存是堆大小动态调控的重要选项之一. 堆内存预估最大值一定小于或等于固定最大值(-Xmx指定的数值). 前者会根据使用情况动态调大或缩小, 以提高GC回收的效率
- MinHeapFreeRatio: GC后如果发现空闲堆内存占到整个预估堆内存的N%(百分比), 则放大堆内存的预估最大值

- MaxHeapSize: 即-Xmx, 堆内存大小的上限
- InitialHeapSize: 即-Xms, 堆内存大小的初始值

- NewSize: 新生代预估堆内存占用的默认值
- MaxNewSize: 新生代占整个堆内存的最大值

- OldSize: 老年代的默认大小, default size of the tenured generation
- NewRatio: 老年代对比新生代的空间大小, 比如2代表老年代空间是新生代的两倍大小. The ratio of old generation to young generation.

- SurvivorRatio: Eden/Survivor的值. 这个值的说明, 很多网上转载的都是错的. 8表示Survivor:Eden=1:8, 因为survivor区有2个, 所以Eden的占比为8/10. Ratio of eden/survivor space size. -XX:SurvivorRatio=6 sets the ratio between each survivor space and eden to be 1:6, each survivor space will be one eighth of the young generation.

- MetaspaceSize: 分配给类元数据空间的初始大小(Oracle逻辑存储上的初始高水位，the initial high-water-mark ). 此值为估计值. MetaspaceSize设置得过大会延长垃圾回收时间. 垃圾回收过后, 引起下一次垃圾回收的类元数据空间的大小可能会变大
- MaxMetaspaceSize: 是分配给类元数据空间的最大值, 超过此值就会触发Full GC. 此值仅受限于系统内存的大小, JVM会动态地改变此值

## 垃圾回收和OOM
#### 堆内内存
minor GC（回收年轻代的内存 复制算法）
full GC （如果老年代放不下了就FGC，如果FGC了也放不下就OOM了）
OOM例子：ThreadLocal在newfixthreadpool里面，每次弱引用的threadlocal被清理了，但是里面map的value还在，时间长就引发了oom

 
## java nio

核心部分：
1. 通道channel
2. 缓冲区buffer
3. 选择器selector

### 特点

IO是面向流的，NIO是面向缓冲区的，NIO数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。

NIO可以设计为非阻塞模式，也就是说没有数据读写的时候，线程会去做其他事情。线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。

通道是双向的，通过一个Channel既可以进行读，也可以进行写；而Stream只能进行单向操作，通过一个Stream只能进行读或者写，比如InputStream只能进行读取操作，OutputStream只能进行写操作

#### Channel
和IO对应的NIO的CHannel主要有：
- FileChannel     （FileIO）
- DatagramChannel      （UDP）
- SocketChannel          （CLient）
- ServerSocketChannel    （Server）

#### Buffer
**介绍**
NIO中的关键Buffer实现有：ByteBuffer, CharBuffer, DoubleBuffer, FloatBuffer, IntBuffer, LongBuffer, ShortBuffer，分别对应基本数据类型。当然NIO中还有MappedByteBuffer, HeapByteBuffer, DirectByteBuffer等这里先不进行陈述。


#### Channel
Selector运行单线程处理多个Channel，如果你的应用打开了多个通道，但每个连接的流量都很低，使用Selector就会很方便。

#### Selector

多线程阻塞状态下，需要读取和分发。这就需要一种方法阻塞等待，直到至少有一个信道可以进行I/O操作，并指出是哪个信道。NIO的选择器就实现了这样的功能。一个Selector实例可以同时检查一组信道的I/O状态。如果用传统的方式来处理这么多客户端，使用的方法是循环地一个一个地去检查所有的客户端是否有I/O操作，如果当前客户端有I/O操作，则可能把当前客户端扔给一个线程池去处理，如果没有I/O操作则进行下一个轮询，当所有的客户端都轮询过了又接着从头开始轮询；这种方法是非常笨而且也非常浪费资源，因为大部分客户端是没有I/O操作，我们也要去检查；而Selector就不一样了，它在内部可以同时管理多个I/O，当一个信道有I/O操作的时候，他会通知Selector，Selector就是记住这个信道有I/O操作，并且知道是何种I/O操作，是读呢？是写呢？还是接受新的连接；所以如果使用Selector，它返回的结果只有两种结果，一种是0，即在你调用的时刻没有任何客户端需要I/O操作，另一种结果是一组需要I/O操作的客户端，这时你就根本不需要再检查了，因为它返回给你的肯定是你想要的。

与Selector一起使用时，Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。

状态
1. SelectionKey.OP_CONNECT
2. SelectionKey.OP_ACCEPT
3. SelectionKey.OP_READ
4. SelectionKey.OP_WRITE

#### 在File层面的操作
- 写入数据到Buffer
		RandomAccessFile aFile = new RandomAccessFile("src/nio.txt","rw");
		FileChannel fileChannel = aFile.getChannel();
		ByteBuffer buf = ByteBuffer.allocate(1024);int bytesRead = fileChannel.read(buf);

- 调用filp()方法
		buf.flip();

- 从Buffer中读取数据
		System.out.print((char)buf.get());

- 调用clear()方法或者compact()方法

IO操作Buffer
1. 向Buffer中写数据：

 从Channel写到Buffer (fileChannel.read(buf))

 通过Buffer的put()方法 （buf.put(…)）

7. 从Buffer中读取数据：

 从Buffer读取到Channel (channel.write(buf))

 使用get()方法从Buffer中读取数据 （buf.get()）

#### [Server和Client层面操作NIO](https://www.jianshu.com/p/d47835316016 "Server和Client层面操作NIO")
- 注册selector
- 分配buffer
- 将serversocketchannel设置为非阻塞，然后再ssc中注册selecor为accept
- 获得selector.select()。select()方法返回的值表示有多少个 Channel 可操作
- 通过selector.selectKey获取key值
- 用set的Iterator循环每个channel，如果对应到相关的状态就按相关的IO处理

Client端和Server端几乎一致